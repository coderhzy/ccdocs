import{_ as t,o as e,c as a,O as r}from"./chunks/framework.44b9e76d.js";const m=JSON.parse('{"title":"类型系统","description":"","frontmatter":{},"headers":[],"relativePath":"ts/ch3.md","filePath":"ts/ch3.md","lastUpdated":1683560449000}'),s={name:"ts/ch3.md"},o=r('<h1 id="类型系统" tabindex="-1">类型系统 <a class="header-anchor" href="#类型系统" aria-label="Permalink to &quot;类型系统&quot;">​</a></h1><h2 id="函数类型" tabindex="-1">函数类型 <a class="header-anchor" href="#函数类型" aria-label="Permalink to &quot;函数类型&quot;">​</a></h2><p>如何对两个函数类型进行兼容性比较？</p><p>即比较它们的参数类型是否是反向的父子类型关系，返回值是否是正向的父子类型关系。</p><blockquote><p>也就是判断参数类型是否遵循类型逆变，返回值类型是否遵循类型协变。</p></blockquote><p>我们可以通过 TypeScript ESLint 的规则以及 <code>strictFunctionTypes</code> 配置，来为 interface 内的函数声明启用严格的检查模式。</p><p>如果项目内配置了 TypeScript ESLint，可以加上 <a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md" target="_blank" rel="noreferrer">method-signature-style</a> 这条规则提升代码质量。</p>',7),c=[o];function i(n,p,l,_,d,h){return e(),a("div",null,c)}const f=t(s,[["render",i]]);export{m as __pageData,f as default};

import{_ as a,c as l,o as i,ah as e}from"./chunks/framework.BjEij7qi.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/javascript/01_deep-run.md","filePath":"frontend/javascript/01_deep-run.md","lastUpdated":1684138789000}'),o={name:"frontend/javascript/01_deep-run.md"},t=e('<h2 id="_1-javascript-应用场景" tabindex="-1">1. JavaScript 应用场景 <a class="header-anchor" href="#_1-javascript-应用场景" aria-label="Permalink to &quot;1. JavaScript 应用场景&quot;">​</a></h2><ol><li>Web 开发 <ol><li>原生 JavaScript</li><li>React 开发</li><li>Vue 开发</li></ol></li><li>移动端开发 <ol><li>ReactNative</li><li>Weex</li></ol></li><li>小程序端开发 <ol><li>微信小程序</li><li>支付宝小程序</li><li>uniapp</li><li>taro</li></ol></li><li>桌面应用开发 <ol><li>Electron (比如 VSCode)</li></ol></li><li>后端开发 <ol><li>Node 环境(比如 express、koa、egg.js)</li></ol></li></ol><h2 id="_2-javascript-核心知识点" tabindex="-1">2. JavaScript 核心知识点 <a class="header-anchor" href="#_2-javascript-核心知识点" aria-label="Permalink to &quot;2. JavaScript 核心知识点&quot;">​</a></h2><h3 id="_2-1-面向对象" tabindex="-1">2.1 面向对象 <a class="header-anchor" href="#_2-1-面向对象" aria-label="Permalink to &quot;2.1 面向对象&quot;">​</a></h3><ul><li>JavaScript 面向对象、继承、 原型、原型链等</li></ul><h3 id="_2-2-函数、闭包" tabindex="-1">2.2 函数、闭包 <a class="header-anchor" href="#_2-2-函数、闭包" aria-label="Permalink to &quot;2.2 函数、闭包&quot;">​</a></h3><ul><li>闭包的访问规则</li><li>闭包的内存泄露</li><li>函数中 this 的指向</li></ul><h3 id="_2-3-es-新特性" tabindex="-1">2.3 ES 新特性 <a class="header-anchor" href="#_2-3-es-新特性" aria-label="Permalink to &quot;2.3 ES 新特性&quot;">​</a></h3><ul><li>ES6、7、8、9、10、11、12 新特性</li></ul><h3 id="_2-4-作用域" tabindex="-1">2.4 作用域 <a class="header-anchor" href="#_2-4-作用域" aria-label="Permalink to &quot;2.4 作用域&quot;">​</a></h3><ul><li>作用域的理解</li><li>作用域提升</li><li>块级作用域</li><li>作用域链</li><li>AO、GO、VO 等概念</li></ul><h3 id="_2-5-其他一系列知识" tabindex="-1">2.5 其他一系列知识 <a class="header-anchor" href="#_2-5-其他一系列知识" aria-label="Permalink to &quot;2.5 其他一系列知识&quot;">​</a></h3><ul><li>事件循环</li><li>微任务</li><li>宏任务</li><li>内存管理</li><li>Promise</li><li>await、 asnyc</li><li>防抖、节流等等</li></ul><h2 id="_3-javascript-高级语言是怎么被执行的" tabindex="-1">3. JavaScript 高级语言是怎么被执行的 <a class="header-anchor" href="#_3-javascript-高级语言是怎么被执行的" aria-label="Permalink to &quot;3. JavaScript 高级语言是怎么被执行的&quot;">​</a></h2><h3 id="_3-1-语言被系统转换并执行" tabindex="-1">3.1 语言被系统转换并执行 <a class="header-anchor" href="#_3-1-语言被系统转换并执行" aria-label="Permalink to &quot;3.1 语言被系统转换并执行&quot;">​</a></h3><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305061311119.png" alt=""></p><ul><li>高级语言 -&gt; 汇编语言 -&gt; 机器语言</li></ul><h3 id="_3-2-浏览器的工作原理" tabindex="-1">3.2 浏览器的工作原理 <a class="header-anchor" href="#_3-2-浏览器的工作原理" aria-label="Permalink to &quot;3.2 浏览器的工作原理&quot;">​</a></h3><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305061312902.png" alt=""></p><ul><li>输入服务器地址</li><li>访问 index.html</li><li>下载 css + 下载 JavaScript</li></ul><h3 id="_3-3-浏览器的内核" tabindex="-1">3.3 浏览器的内核 <a class="header-anchor" href="#_3-3-浏览器的内核" aria-label="Permalink to &quot;3.3 浏览器的内核&quot;">​</a></h3><blockquote><p>浏览器内核指的是浏览器排版引擎</p></blockquote><ul><li>Gecko</li><li>Trident</li><li>Webkit</li><li>Blink</li></ul><h3 id="_3-4-浏览器渲染引擎" tabindex="-1">3.4 浏览器渲染引擎 <a class="header-anchor" href="#_3-4-浏览器渲染引擎" aria-label="Permalink to &quot;3.4 浏览器渲染引擎&quot;">​</a></h3><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305070900008.png" alt=""></p><ol><li>将 html 进行<strong>解析</strong>, 将其转换成 DOMTree</li><li>将 css 进行<strong>解析</strong>, 将其转换成 styleRules</li><li>将两者合并, 通过 layout 进行布局排版, 形成渲染树</li><li>通过浏览器<code>Painting</code>, 最终渲染到浏览器上</li></ol><h3 id="_3-5-v8-引擎原理" tabindex="-1">3.5 V8 引擎原理 <a class="header-anchor" href="#_3-5-v8-引擎原理" aria-label="Permalink to &quot;3.5 V8 引擎原理&quot;">​</a></h3><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305070904137.png" alt=""></p><ol><li>解析(parse): 词法分<em>生成 tokens</em>和语法分析 <ol><li><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305070908088.png" alt=""></li></ol></li><li>形成抽象语法树(AST)</li><li>通过<em>Ignition</em>转换成字节码<em>bytecode</em>.</li><li><em>TurboFan</em>: 追踪热点函数标记为(hot), 记录对应的机器指令, 下次再执行代码时候,直接执行这个机器指令. 如果此时机器码受到操作设备问题, 那么通过<strong>Deoptimization</strong>将机器码转换成字节码, 再进行转换为汇编 -&gt; 机器码.</li></ol><h3 id="_3-6-v8-引擎架构" tabindex="-1">3.6 v8 引擎架构 <a class="header-anchor" href="#_3-6-v8-引擎架构" aria-label="Permalink to &quot;3.6 v8 引擎架构&quot;">​</a></h3><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305070932678.png" alt=""></p><ol><li><code>Blink</code>内核,加载 html, 下载 JavaScript 代码. 通过<code>stream流方式</code>传递给 V8 引擎.</li><li>通过<em>Scanner 扫描器</em>, 转化成 <strong>tokens</strong>. 将 tokens 给 Parser, <strong>Parser</strong>将其转换成<strong>AST 树</strong>.</li><li>再通过<em>Ignition</em>来将其转换成字节码, 最后转换成<strong>CPU 可以执行的指令</strong></li><li>图上方的<code>PerParser</code><ol><li><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305070938502.png" alt=""></li></ol></li></ol><h2 id="_4-javascript-代码执行原理" tabindex="-1">4. JavaScript 代码执行原理 <a class="header-anchor" href="#_4-javascript-代码执行原理" aria-label="Permalink to &quot;4. JavaScript 代码执行原理&quot;">​</a></h2><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305070904137.png" alt=""></p><ol><li>从源代码 到 AST 这一步, V8 引擎内部会帮助我们创建一个对象(GlobalObject -&gt; go) 并附带 window</li><li>运行代码: <ol><li>v8 为了执行代码,内部有个<strong>执行上下文栈</strong>(Execution Context Stack, EC Stack)(函数调用栈)</li><li>为了执行全局代码, V8 会创建<code>GO(Golbal Execution Context)</code>. 在 GO 中执行代码,又会有<code>VO(Variable Object)</code>, 对于执行全局代码执行时,此时的<code>VO===GO</code>. 从而再执行代码</li><li>如果执行代码时候,有函数则对函数单独生成<code>函数执行上下文(FEC) - Functional Execution Context</code>, 并在函数内部定义一个<code>VO===AO</code>, 此时还会加一个<code>作用域链</code><strong>scope chain = VO + ParentScope</strong>, 也就是所谓的函数作用域. <img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305102301226.png" alt=""></li></ol></li></ol><h3 id="_4-1-环境变量" tabindex="-1">4.1 环境变量 <a class="header-anchor" href="#_4-1-环境变量" aria-label="Permalink to &quot;4.1 环境变量&quot;">​</a></h3><ul><li>VO <img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202305102339974.png" alt=""></li></ul><h2 id="_5-垃圾回收" tabindex="-1">5. 垃圾回收 <a class="header-anchor" href="#_5-垃圾回收" aria-label="Permalink to &quot;5. 垃圾回收&quot;">​</a></h2><h3 id="_5-1-引用计数" tabindex="-1">5.1 引用计数 <a class="header-anchor" href="#_5-1-引用计数" aria-label="Permalink to &quot;5.1 引用计数&quot;">​</a></h3><ol><li>当 a 被 b 引用, 那么 a 计数加一, a 再被 c 引用, 计数再加一. 手动将引用设置为 null, 则计数减一. 当计数为 0,则被清除</li><li><strong>引用计数缺陷</strong>: 两个对象存在循环引用的问题, 那么这内存永远不会被释放.</li></ol><h3 id="_5-2-标记清除" tabindex="-1">5.2 标记清除 <a class="header-anchor" href="#_5-2-标记清除" aria-label="Permalink to &quot;5.2 标记清除&quot;">​</a></h3><ol><li>算法从设置一个根对象, 垃圾回收期会定期从这个根开始, 找所有从根开始有引用到的对象,对于哪些没有引用到的对象,就认为是不可用的对象.</li></ol>',42),r=[t];function s(c,n,h,d,p,u){return i(),l("div",null,r)}const b=a(o,[["render",s]]);export{g as __pageData,b as default};

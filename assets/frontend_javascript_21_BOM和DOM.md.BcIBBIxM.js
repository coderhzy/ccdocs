import{_ as a,c as e,o as l,ah as i}from"./chunks/framework.BjEij7qi.js";const b=JSON.parse('{"title":"BOM和DOM","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/javascript/21_BOM和DOM.md","filePath":"frontend/javascript/21_BOM和DOM.md","lastUpdated":1687132616000}'),t={name:"frontend/javascript/21_BOM和DOM.md"},o=i('<h1 id="bom和dom" tabindex="-1">BOM和DOM <a class="header-anchor" href="#bom和dom" aria-label="Permalink to &quot;BOM和DOM&quot;">​</a></h1><h2 id="_1-bom" tabindex="-1">1. BOM <a class="header-anchor" href="#_1-bom" aria-label="Permalink to &quot;1. BOM&quot;">​</a></h2><h3 id="_1-1-认识bom" tabindex="-1">1.1 认识BOM <a class="header-anchor" href="#_1-1-认识bom" aria-label="Permalink to &quot;1.1 认识BOM&quot;">​</a></h3><p>JavaScript 通过 BOM 可以操作浏览器的窗口、文档、地址栏等, 可以将BOM看成连接JavaScript和浏览器窗口之间的桥梁</p><h3 id="_1-2-bom的组成" tabindex="-1">1.2 BOM的组成 <a class="header-anchor" href="#_1-2-bom的组成" aria-label="Permalink to &quot;1.2 BOM的组成&quot;">​</a></h3><ul><li>BOM主要包括以下对象类型 <ul><li>window: 包括全局属性、方法，控制浏览器窗口相关的属性、方法; <ul><li>身份一: 全局对象</li><li>身份二: 浏览器窗口对象(查询地址<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noreferrer">MDN-window</a>) <ul><li>属性: localStorage、console、location、history、screenX、scrollX</li><li>方法: alert、close、scrollTo、open、print、confirm、prompt</li><li>事件: onload、onunload、onresize、onerror,focus、blur、load、hashchange</li><li>其他: 包含从EventTarget继承过来的方法，addEventListener、removeEventListener、dispatchEvent方法;</li></ul></li></ul></li><li>location: 包括浏览器地址栏相关的属性、方法;</li><li>history: 包括浏览器历史记录相关的属性、方法;</li><li>document: 当前窗口操作文档的对象;</li></ul></li></ul><h2 id="_2-dom" tabindex="-1">2. DOM <a class="header-anchor" href="#_2-dom" aria-label="Permalink to &quot;2. DOM&quot;">​</a></h2><h3 id="_2-1-一图胜千言" tabindex="-1">2.1 一图胜千言 <a class="header-anchor" href="#_2-1-一图胜千言" aria-label="Permalink to &quot;2.1 一图胜千言&quot;">​</a></h3><ul><li>JavaScript通过DOM可以对页面中的元素进行操作</li><li><strong>因为继承自EventTarget，所以也可以使用EventTarget的方法. (元素可以addEventListener、removeEventListener、dispatchEvent方法的本质)</strong></li></ul><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202306190709818.png" alt=""></p><h3 id="_2-2-dom的组成" tabindex="-1">2.2 DOM的组成 <a class="header-anchor" href="#_2-2-dom的组成" aria-label="Permalink to &quot;2.2 DOM的组成&quot;">​</a></h3><ul><li>Node节点 <ul><li>nodeName: 节点名称</li><li>nodeType: 节点类型</li><li>nodeValue: 节点值</li><li>parentNode: 父节点</li><li>childNodes: 子节点</li></ul></li><li>Document: Document节点表示的整个载入的网页，我们来看一下常见的属性和方法</li><li>Element: Element节点表示的是HTML或者XML文档中的元素，我们来看一下常见的属性和方法</li><li>Attr: Attr节点表示的是HTML或者XML文档中的属性，我们来看一下常见的属性和方法</li><li>Text: Text节点表示的是HTML或者XML文档中的文本内容，我们来看一下常见的属性和方法</li></ul><h3 id="_2-3-事件监听" tabindex="-1">2.3 事件监听 <a class="header-anchor" href="#_2-3-事件监听" aria-label="Permalink to &quot;2.3 事件监听&quot;">​</a></h3><h4 id="_2-3-1-什么是事件监听" tabindex="-1">2.3.1 什么是事件监听 <a class="header-anchor" href="#_2-3-1-什么是事件监听" aria-label="Permalink to &quot;2.3.1 什么是事件监听&quot;">​</a></h4><p>事件监听的本质: 事件监听的本质就是在事件源上注册一个事件处理函数，当事件发生时，执行事件处理函数</p><h4 id="_2-3-2-事件监听的三种方式" tabindex="-1">2.3.2 事件监听的三种方式 <a class="header-anchor" href="#_2-3-2-事件监听的三种方式" aria-label="Permalink to &quot;2.3.2 事件监听的三种方式&quot;">​</a></h4><ul><li>在script中直接监听</li><li>通过元素的on来监听事件</li><li>通过EventTarget的addEventListener方法来监听事件</li></ul><h3 id="_2-4-事件流" tabindex="-1">2.4 事件流 <a class="header-anchor" href="#_2-4-事件流" aria-label="Permalink to &quot;2.4 事件流&quot;">​</a></h3><h4 id="_2-4-1-什么是事件流" tabindex="-1">2.4.1 什么是事件流 <a class="header-anchor" href="#_2-4-1-什么是事件流" aria-label="Permalink to &quot;2.4.1 什么是事件流&quot;">​</a></h4><ul><li>当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身;</li><li>因为我们的HTML元素是存在父子元素叠加层级的;</li><li>比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的;</li></ul><h4 id="_2-4-2-事件冒泡和事件捕获" tabindex="-1">2.4.2 事件冒泡和事件捕获 <a class="header-anchor" href="#_2-4-2-事件冒泡和事件捕获" aria-label="Permalink to &quot;2.4.2 事件冒泡和事件捕获&quot;">​</a></h4><ul><li>事件冒泡: 事件从最具体的元素开始接收，然后逐级向上传播到较为不具体的节点(文档)(由内向外)</li><li>事件捕获: 事件从最不具体的节点(文档)开始接收，然后逐级向下传播到较为具体的节点(由外向内)</li></ul><p><img src="https://imgsbed-1301560453.cos.ap-shanghai.myqcloud.com//blog202306190752811.png" alt=""></p><h3 id="_2-5-事件对象event" tabindex="-1">2.5 事件对象event <a class="header-anchor" href="#_2-5-事件对象event" aria-label="Permalink to &quot;2.5 事件对象event&quot;">​</a></h3><h4 id="_2-5-1-什么是事件对象" tabindex="-1">2.5.1 什么是事件对象 <a class="header-anchor" href="#_2-5-1-什么是事件对象" aria-label="Permalink to &quot;2.5.1 什么是事件对象&quot;">​</a></h4><ul><li>事件的类型是什么，你点击的是哪一个元素，点击的位置是哪里等等相关的信息;</li><li>那么这些信息会被封装到一个Event对象中;</li><li>该对象给我们提供了想要的一些属性，以及可以通过该对象进行某些操作;</li></ul><h4 id="_2-5-2-事件对象的属性" tabindex="-1">2.5.2 事件对象的属性 <a class="header-anchor" href="#_2-5-2-事件对象的属性" aria-label="Permalink to &quot;2.5.2 事件对象的属性&quot;">​</a></h4><ul><li>type: <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noreferrer">事件类型</a></li><li>target: 事件源(当事件发生的元素)</li><li>currentTarget: 当前事件所绑定的元素</li><li>offsetX、offsetY:点击元素的位置;</li></ul><h4 id="_2-5-3-事件对象的方法" tabindex="-1">2.5.3 事件对象的方法 <a class="header-anchor" href="#_2-5-3-事件对象的方法" aria-label="Permalink to &quot;2.5.3 事件对象的方法&quot;">​</a></h4><ul><li>preventDefault: 阻止默认行为</li><li>stopPropagation: 阻止事件冒泡</li></ul>',30),r=[o];function n(h,d,s,c,u,_){return l(),e("div",null,r)}const p=a(t,[["render",n]]);export{b as __pageData,p as default};
